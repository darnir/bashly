#!/usr/bin/env bash
object__new () 
{ 
    typeset class_description=$1 input_properties=$2;
    typeset field;
    typeset name;
    typeset value;
    typeset class;
    typeset -a fields;
    typeset -A properties;
    IFS=';' read -ra fields <<< "$class_description";
    for field in "${fields[@]}";
    do
        [[ -n $field ]] || return 1;
        properties["$field"]=y;
    done;
    IFS=';' read -ra fields <<< "$input_properties";
    for field in "${fields[@]}";
    do
        IFS=':' read -rd '' name value <<< "$field";
        value=${value%'
'};
        [[ -n "${properties["$name"]+set}" ]] || { 
            printf -- '-%s:%s\0' "$name" "$value";
            return 2
        };
        printf '%s:%s\0' "$name" "$value";
    done
}

cmdline__arguments () 
{ 
    :  <<EOD
  cmdline__arguments 

  env vars:

  - errors_not_fatal
  - dashdash_not_special
EOD

    typeset key
    typeset value;
    typeset shift;
    typeset argument;
    typeset options;
    typeset stop_parsing;
    typeset return_code;
    IFS=: read -rd '' shift options < <(cmdline__p__parse_descriptions "$@") || return;
    shift "${shift:-0}";
    if [[ $1 = '--' ]]; then
        shift;
    else
        return 2;
    fi;
    cmdline__p__consume_arguments "$@"
}
cmdline__help () 
{ 
    :
}
cmdline__p__arguments__long () 
{ 
    typeset long;
    typeset name;
    typeset arguments;
    typeset i;
    typeset -a options;
    typeset -A arguments_table;
    typeset -A name_table;
    IFS=';' read -ra options <<< "$1";
    shift;
    for option in "${options[@]}";
    do
        IFS=':' read -r name _ long arguments <<< "$option";
        arguments_table["$long"]=$arguments;
        name_table["$long"]=$name;
    done;
    [[ $1 = --[!-]* ]] || return 1;
    [[ -n ${arguments_table["${1#--}"]+set} ]] || return 1;
    [[ -n ${name_table["${1#--}"]+set} ]] || return 1;
    arguments=${arguments_table["${1#--}"]};
    name=${name_table["${1#--}"]};
    shift;
    ((arguments <= $#)) || return 1;
    printf %s "$((arguments + 1))";
    if ((arguments > 0)); then
        for ((i = 1; i <= arguments; i++))
        do
            printf '%s:%s\0' "$name" "${!i}";
        done;
    else
        printf '%s\0' "$name";
    fi 1>&3
}
cmdline__p__arguments__short () 
{ 
    typeset short;
    typeset name;
    typeset arguments;
    typeset i;
    typeset -a options;
    typeset -A arguments_table;
    typeset -A name_table;
    IFS=';' read -ra options <<< "$1";
    shift;
    for option in "${options[@]}";
    do
        IFS=':' read -r name short _ arguments <<< "$option";
        arguments_table["$short"]=$arguments;
        name_table["$short"]=$name;
    done;
    [[ $1 = -[!-] ]] || return 1;
    [[ -n ${arguments_table["${1#-}"]+set} ]] || return 1;
    [[ -n ${name_table["${1#-}"]+set} ]] || return 1;
    arguments=${arguments_table["${1#-}"]};
    name=${name_table["${1#-}"]};
    shift;
    ((arguments <= $#)) || return 1;
    printf %s "$((arguments + 1))";
    if ((arguments > 0)); then
        for ((i = 1; i <= arguments; i++))
        do
            printf '%s:%s\0' "$name" "${!i}";
        done;
    else
        printf '%s\0' "$name";
    fi 1>&3
}
cmdline__p__arguments__short_composed () 
{ 
    typeset options_description=$1;
    typeset short;
    typeset rest;
    typeset arguments;
    typeset shift;
    typeset flag;
    typeset i;
    typeset -a options;
    typeset -a flags;
    typeset -a last_option;
    typeset -A arguments_table;
    IFS=';' read -ra options <<< "$options_description";
    shift;
    for option in "${options[@]}";
    do
        IFS=':' read -r name short _ arguments <<< "$option";
        arguments_table["$short"]=$arguments;
    done;
    rest=$1;
    shift;
    while [[ -n $rest ]]; do
        short=${rest#-} rest=${short#?} short=${short%"$rest"};
        [[ -n ${arguments_table["$short"]+set} ]] || return 1;
        arguments=${arguments_table["$short"]};
        if ((arguments == 0)); then
            flags+=("-$short");
        else
            if ((arguments > 0)) && [[ -n $rest ]]; then
                last_option=("-$short" "$rest" "$@") shift=$arguments;
                break;
            else
                if ((arguments > 0)); then
                    last_option=("-$short" "$@") shift=$((arguments + 1));
                    break;
                else
                    return 1;
                fi;
            fi;
        fi;
    done;
    if [[ -n $last_option ]]; then
        printf %s $shift;
    else
        printf %s 1;
    fi;
    for flag in "${flags[@]}";
    do
        cmdline__p__arguments__short "$options_description" "$flag" > /dev/null;
    done;
    cmdline__p__arguments__short "$options_description" "${last_option[@]}" > /dev/null
}
cmdline__p__consume_arguments () 
{ 
    typeset options=$1;
    shift;
    typeset argument;
    typeset stop_parsing;
    typeset helper;
    while (($# > 0)); do
        if [[ -n $stop_parsing ]]; then
            printf '@:%s\0' "$1";
            shift;
            continue;
        fi;
        helper=;
        case $1 in 
            -[!-])
                helper=cmdline__p__arguments__short
            ;;
            -[!-]*)
                helper=cmdline__p__arguments__short_composed
            ;;
            --[!-]*)
                if [[ $1 = --+([!=-])=* ]]; then
                    IFS='=' read -rd '' key value <<< "$1";
                    value=${value%'
'};
                    shift 1;
                    set -- "$key" "$value" "$@";
                fi;
                helper=cmdline__p__arguments__long
            ;;
            --)
                stop_parsing=y
            ;;
            *)
                printf '@:%s\0' "$1"
            ;;
        esac;
        if [[ -n $helper ]]; then
            { 
                shift=$("$helper" "$options" "$@") || return 1
            } 3>&1;
            shift "$((shift))";
        else
            shift;
        fi;
    done
}
cmdline__p__parse_descriptions () 
{ 
    typeset option_description;
    typeset option_object;
    typeset key;
    typeset value;
    typeset shift;
    typeset argument;
    typeset name;
    typeset short;
    typeset long;
    typeset -a option_descriptions;
    option_object='name;short;long;arguments;help';
    shift=0;
    for option_description in "$@";
    do
        [[ $option_description = '--' ]] && break;
        ((shift++));
        name= short= long= arguments=0;
        while IFS=: read -rd '' key value; do
            case $key in 
                -*)
                    return 1
                ;;
                name | short | long | arguments)
                    typeset "$key=$value"
                ;;
            esac;
        done < <(object__new "$option_object" "$option_description");
        option_descriptions+=("$name:$short:$long:$arguments");
    done;
    ( IFS=';';
    printf %s:%s "$shift" "${option_descriptions[*]}" )
}

main () 
{ 
    :  <<EOD
  I tried hard to duplicate the brain-dead argument parsing of the
  echo builtin, but it's still not an accurate clone. It parses
  arguments even after arguments.
EOD

    typeset separator no_trailing_newline interpret_backslashes
    typeset type value argument;
    typeset -a options=('name:no_trailing_newline;short:n' 'name:interpret_backslashes;short:e' 'name:no_interpret_backslashes;short:E');
    typeset -a arguments;
    errors_not_fatal=y dashdash_not_special=y cmdline__arguments "${options[@]}" -- "$@" | { 
        while IFS=: read -rd '' type value; do
            case $type in 
                @ | -)
                    arguments+=("$separator$value");
                    separator=' '
                ;;
                no_trailing_newline)
                    no_trailing_newline=y
                ;;
                interpret_backslashes)
                    interpret_backslashes=y
                ;;
                no_interpret_backslashes)
                    interpret_backslashes=
                ;;
            esac;
        done;
        for argument in "${arguments[@]}";
        do
            if [[ -n $interpret_backslashes ]]; then
                printf %b "$argument";
            else
                printf %s "$argument";
            fi;
        done;
        if [[ ! -n $no_trailing_newline ]]; then
            printf \\n;
        fi
    }
}
main "$@"
