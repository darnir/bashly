#!/usr/bin/env bash
object__new () 
{ 
    typeset class_description=$1 input_properties=$2;
    typeset field;
    typeset name;
    typeset value;
    typeset class;
    typeset -a fields;
    typeset -A properties;
    IFS=';' read -ra fields <<< "$class_description";
    for field in "${fields[@]}";
    do
        [[ -n $field ]] || return 1;
        properties["$field"]=y;
    done;
    IFS=';' read -ra fields <<< "$input_properties";
    for field in "${fields[@]}";
    do
        IFS=':' read -rd '' name value <<< "$field";
        value=${value%'
'};
        [[ -n "${properties["$name"]+set}" ]] || { 
            printf -- '-%s:%s\0' "$name" "$value";
            return 2
        };
        printf '%s:%s\0' "$name" "$value";
    done
}

cmdline__arguments () 
{ 
    :  <<EOD
  cmdline__arguments 

  env vars:

  - errors_not_fatal
  - dashdash_not_special
EOD

    typeset key
    typeset value;
    typeset shift;
    typeset argument;
    typeset options;
    typeset stop_parsing;
    typeset return_code;
    IFS=: read -rd '' shift options < <(cmdline__p__parse_descriptions "$@") || return;
    shift "${shift:-0}";
    if [[ $1 = '--' ]]; then
        shift;
    else
        return 2;
    fi;
    cmdline__p__consume_arguments "$@"
}
cmdline__help () 
{ 
    :
}
cmdline__p__arguments__long () 
{ 
    typeset long;
    typeset name;
    typeset arguments;
    typeset i;
    typeset -a options;
    typeset -A arguments_table;
    typeset -A name_table;
    IFS=';' read -ra options <<< "$1";
    shift;
    for option in "${options[@]}";
    do
        IFS=':' read -r name _ long arguments <<< "$option";
        arguments_table["$long"]=$arguments;
        name_table["$long"]=$name;
    done;
    [[ $1 = --[!-]* ]] || return 1;
    [[ -n ${arguments_table["${1#--}"]+set} ]] || return 1;
    [[ -n ${name_table["${1#--}"]+set} ]] || return 1;
    arguments=${arguments_table["${1#--}"]};
    name=${name_table["${1#--}"]};
    shift;
    ((arguments <= $#)) || return 1;
    printf %s "$((arguments + 1))";
    if ((arguments > 0)); then
        for ((i = 1; i <= arguments; i++))
        do
            printf '%s:%s\0' "$name" "${!i}";
        done;
    else
        printf '%s\0' "$name";
    fi 1>&3
}
cmdline__p__arguments__short () 
{ 
    typeset short;
    typeset name;
    typeset arguments;
    typeset i;
    typeset -a options;
    typeset -A arguments_table;
    typeset -A name_table;
    IFS=';' read -ra options <<< "$1";
    shift;
    for option in "${options[@]}";
    do
        IFS=':' read -r name short _ arguments <<< "$option";
        arguments_table["$short"]=$arguments;
        name_table["$short"]=$name;
    done;
    [[ $1 = -[!-] ]] || return 1;
    [[ -n ${arguments_table["${1#-}"]+set} ]] || return 1;
    [[ -n ${name_table["${1#-}"]+set} ]] || return 1;
    arguments=${arguments_table["${1#-}"]};
    name=${name_table["${1#-}"]};
    shift;
    ((arguments <= $#)) || return 1;
    printf %s "$((arguments + 1))";
    if ((arguments > 0)); then
        for ((i = 1; i <= arguments; i++))
        do
            printf '%s:%s\0' "$name" "${!i}";
        done;
    else
        printf '%s\0' "$name";
    fi 1>&3
}
cmdline__p__arguments__short_composed () 
{ 
    typeset options_description=$1;
    typeset short;
    typeset rest;
    typeset arguments;
    typeset shift;
    typeset flag;
    typeset i;
    typeset -a options;
    typeset -a flags;
    typeset -a last_option;
    typeset -A arguments_table;
    IFS=';' read -ra options <<< "$options_description";
    shift;
    for option in "${options[@]}";
    do
        IFS=':' read -r name short _ arguments <<< "$option";
        arguments_table["$short"]=$arguments;
    done;
    rest=$1;
    shift;
    while [[ -n $rest ]]; do
        short=${rest#-} rest=${short#?} short=${short%"$rest"};
        [[ -n ${arguments_table["$short"]+set} ]] || return 1;
        arguments=${arguments_table["$short"]};
        if ((arguments == 0)); then
            flags+=("-$short");
        else
            if ((arguments > 0)) && [[ -n $rest ]]; then
                last_option=("-$short" "$rest" "$@") shift=$arguments;
                break;
            else
                if ((arguments > 0)); then
                    last_option=("-$short" "$@") shift=$((arguments + 1));
                    break;
                else
                    return 1;
                fi;
            fi;
        fi;
    done;
    if [[ -n $last_option ]]; then
        printf %s $shift;
    else
        printf %s 1;
    fi;
    for flag in "${flags[@]}";
    do
        cmdline__p__arguments__short "$options_description" "$flag" > /dev/null;
    done;
    cmdline__p__arguments__short "$options_description" "${last_option[@]}" > /dev/null
}
cmdline__p__consume_arguments () 
{ 
    typeset options=$1;
    shift;
    typeset argument;
    typeset stop_parsing;
    typeset helper;
    while (($# > 0)); do
        if [[ -n $stop_parsing ]]; then
            printf '@:%s\0' "$1";
            shift;
            continue;
        fi;
        helper=;
        case $1 in 
            -[!-])
                helper=cmdline__p__arguments__short
            ;;
            -[!-]*)
                helper=cmdline__p__arguments__short_composed
            ;;
            --[!-]*)
                if [[ $1 = --+([!=-])=* ]]; then
                    IFS='=' read -rd '' key value <<< "$1";
                    value=${value%'
'};
                    shift 1;
                    set -- "$key" "$value" "$@";
                fi;
                helper=cmdline__p__arguments__long
            ;;
            --)
                stop_parsing=y
            ;;
            *)
                printf '@:%s\0' "$1"
            ;;
        esac;
        if [[ -n $helper ]]; then
            { 
                shift=$("$helper" "$options" "$@") || return 1
            } 3>&1;
            shift "$((shift))";
        else
            shift;
        fi;
    done
}
cmdline__p__parse_descriptions () 
{ 
    typeset option_description;
    typeset option_object;
    typeset key;
    typeset value;
    typeset shift;
    typeset argument;
    typeset name;
    typeset short;
    typeset long;
    typeset -a option_descriptions;
    option_object='name;short;long;arguments;help';
    shift=0;
    for option_description in "$@";
    do
        [[ $option_description = '--' ]] && break;
        ((shift++));
        name= short= long= arguments=0;
        while IFS=: read -rd '' key value; do
            case $key in 
                -*)
                    return 1
                ;;
                name | short | long | arguments)
                    typeset "$key=$value"
                ;;
            esac;
        done < <(object__new "$option_object" "$option_description");
        option_descriptions+=("$name:$short:$long:$arguments");
    done;
    ( IFS=';';
    printf %s:%s "$shift" "${option_descriptions[*]}" )
}

log__basic () 
{ 
    typeset argument;
    for argument in "$@";
    do
        printf '%s: %s\n' "${BASH_SOURCE##*/}" "$argument";
    done
}
log__debug () 
{ 
    typeset debug_level log_level;
    shift 2;
    if ((log_level >= debug_level)); then
        log__with_type DEBUG "$@";
    fi
}
log__error () 
{ 
    log__with_type ERROR "$@"
}
log__info () 
{ 
    log__with_type INFO "$@"
}
log__warning () 
{ 
    log__with_type WARNING "$@"
}
log__with_type () 
{ 
    typeset type=$1 argument;
    shift;
    for argument in "$@";
    do
        log__basic "$type: $argument" 1>&2;
    done
}

common__die () 
{ 
    typeset exit_status=$2;
    log__error "$1";
    exit "${exit_status:-1}"
}

log__basic () 
{ 
    typeset argument;
    for argument in "$@";
    do
        printf '%s: %s\n' "${BASH_SOURCE##*/}" "$argument";
    done
}
log__debug () 
{ 
    typeset debug_level log_level;
    shift 2;
    if ((log_level >= debug_level)); then
        log__with_type DEBUG "$@";
    fi
}
log__error () 
{ 
    log__with_type ERROR "$@"
}
log__info () 
{ 
    log__with_type INFO "$@"
}
log__warning () 
{ 
    log__with_type WARNING "$@"
}
log__with_type () 
{ 
    typeset type=$1 argument;
    shift;
    for argument in "$@";
    do
        log__basic "$type: $argument" 1>&2;
    done
}

main () 
{ 
    typeset type_ value;
    typeset type length source;
    typeset -a options=('name:type;short:t;long:type;arguments:1' 'name:length;short:n;long:length;arguments:1' 'name:source;short:s;long:source;arguments:1' 'name:help;short:h;long:help');
    type=hex length=8 source=/dev/urandom;
    while IFS=: read -rd '' type_ value; do
        case $type_ in 
            type)
                type=$value
            ;;
            length)
                length=$value
            ;;
            source)
                source=$value
            ;;
            help)
                cmdline__help "${options[@]}"
            ;;
            *)
                common__die "unexpected ''$value''"
            ;;
        esac;
    done < <(cmdline__arguments "${options[@]}" -- "$@");
    log__debug "type: $type";
    log__debug "length: $length";
    log__debug "source: $source";
    case $type in 
        xdigit | alnum | alpha | digit)
            printf '%s\n' "$(tr -cd "[:$type:]" < "$source" | head -c "$length")"
        ;;
        *)
            common__die "wrong type ''$type''"
        ;;
    esac
}
main "$@"
