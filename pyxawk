#!/usr/bin/awk -f

function hex(h,     ht, v) {
    ht = "0123456789abcdef";
    n = length(h);

    for(i = n; i > 0; i--) {
        v += (index(ht, substr(h, i, 1))-1) * 16 ** (n - i);
    }

    return v;
}

# I know, it's ugly, but works.
function xb(d,      s, xt, n, i) {
    xt = xt"\0\001\002\003\004\005\006\a\b\t\n\v\f\r\016\017\020\021\022\023";
    xt = xt"\024\025\026\027\030\031\032\033\034\035\036\037!\"#$%&'()*+,-./0";
    xt = xt"123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnop";
    xt = xt"qrstuvwxyz{|}~\177\200\201\202\203\204\205\206\207\210\211\212\213";
    xt = xt"\214\215\216\217\220\221\222\223\224\225\226\227\230\231\232\233";
    xt = xt"\234\235\236\237\240\241\242\243\244\245\246\247\250\251\252\253";
    xt = xt"\254\255\256\257\260\261\262\263\264\265\266\267\270\271\272\273";
    xt = xt"\274\275\276\277\300\301\302\303\304\305\306\307\310\311\312\313";
    xt = xt"\314\315\316\317\320\321\322\323\324\325\326\327\330\331\332\333";
    xt = xt"\334\335\336\337\340\341\342\343\344\345\346\347\350\351\352\353";
    xt = xt"\354\355\356\357\360\361\362\363\364\365\366\367\370\371\372\373";
    xt = xt"\374\375\376\377";

    d = sprintf("%0"int((length(d)+1)/2)*2"d", d);

    n = length(d);
    for(i = 1; i <= n; i += 2) {
        s = s substr(xt, substr(d, i, 2)+1, 1);
    }

    return s;
}

function escape(s) {
    gsub(/\n/, "\\n", s);
    gsub(/\r/, "\\r", s);

    return s;
}

function entity(ent,    xb) {
    if(ent ~ /^#[[:digit:]]+$/) {
        ent = substr(ent, 2);
        return escape(xb(ent));
    } else if(ent ~ /^#[Xx][[:xdigit:]]+$/) {
        ent = hex(tolower(substr(ent, 3)));
        return escape(xb(ent));
    } else if(ent in entities) {
        return entities[ent];
    } else {
        pe("x", "X");
    }
}

# Handle printing. FIXME: Entities.
function px(d) {
    print d;
}

function pu(d,      s, rstart, rlength) {
    s = "";

    while(match(d, /&[^&;]+;/)) {
        rstart = RSTART;
        rlength = RLENGTH;

        s = s substr(d, 1, rstart-1);
        s = s entity(substr(d, rstart+1, rlength-2));
        d = substr(d, rstart+rlength);
    }

    print s;
}

function pe(r, m) {
    printf "pyxawk: error: [L=%d] %s: `%s'\n", NR, r, m > "/dev/stderr";
}

function pdata(d) {
    pu("-" d);
}

function pattr(d) {
    sub(/=["']/, " ", d);
    sub(/["'][[:space:]]*$/, "", d);
    pu("A" d);
}

function pcomment(d) {
    px("#" d);
}

function pcdata(d) {
    px("$" d);
}

function petag(d) {
    px(")" d);
}

function pstag(d) {
    px("(" d);
}

function ppi(d) {
    sub(/[?][[:space:]]*$/, "", d);
    px("?" d);
}

BEGIN {
    ST_Z        = 0;
    ST_TAG      = 1;
    ST_DQUOTE   = 2;
    ST_SQUOTE   = 3;
    ST_COMMENT  = 4;
    ST_CDATA    = 5;
    ST_PI       = 6;

    entities["lt"]  = "<";
    entities["gt"]  = ">";
    entities["amp"] = "&";
}

{
    sub(/\r$/, "", $0);

    n = length;
    for(i = 1; i <= n + 1; i++) {
        chr = substr($0, i, 1);

        if(ST_Z == st) {
            if("<" == chr) {

                sstr = substr($0, i+1);
                if("!" == substr(sstr, 1, 1)) {
                    if(sstr ~ /^!--/) {
                        st = ST_COMMENT;
                    } else if(sstr ~ /^!\[CDATA\[/) {
                        st = ST_CDATA;
                    }

                    if(length(buffer)) {
                        pdata(buffer);
                    }
                    buffer = (chr==""?"\\n":(chr=="\\"?"\\\\":chr));
                } else if("?" == substr(sstr, 1, 1)) {
                    st = ST_PI;
                } else if(match(substr($0, i), /^<\/[^<&>/[:space:]]+/)) {
                    rstart = RSTART;
                    rlength = RLENGTH;
                    st = ST_Z;

                    if(attr) {
                        pattr(buffer);
                        attr = 0;
                        buffer = "";
                    }

                    if(length(buffer)) {
                        pdata(buffer);
                        buffer = "";
                    }

                    petag(substr($0, i+rstart+1, rlength-2));

                    i += rlength;

                    if(">" != substr($0, i, 1)) {

                        if("" != substr($0, i, 1)) {
                            pe("expecting space", substr($0, i));
                        }

                        break_flag = 1;
                        while(break_flag) {
                            if(0 > getline) {
                                pe("expecting >", "<EOF>");
                            }

                            n = length;
                            for(i = 1; i <= n; i++) {
                                chr = substr($0, i, 1);

                                if(chr ~ /^[[:space:]]?$/) {
                                    continue;
                                } else if(">" != chr) {
                                    pe("expecting >", substr($0, i));
                                }

                                break_flag = 0;
                                break;
                            }

                        }
                    }
                } else {
                    st = ST_TAG;

                    if(length(buffer)) {
                        pdata(buffer);
                        buffer = "";
                    }

                    # I know, NameChar, but, it's easier this way...
                    if(match(substr($0, i), /^<[^<&>/[:space:]]+/)) {
                        rstart = RSTART;
                        rlength = RLENGTH;

                        prev_tag = substr($0, i+rstart-1, rlength)

                        pstag(substr($0, i+rstart, rlength-1));

                        i += rlength - 1;
                    } else {
                        st = ST_Z;

                        pe("unexpected <", substr($0, i));
                    }
                }
            } else {
                buffer = buffer (chr==""?"\\n":(chr=="\\"?"\\\\":chr));
            }
        } else if(ST_TAG == st) {
            if("<" == chr) {
                s = ST_Z;

                pe("unexpected <", substr($0, i));
            } else if("/" == chr) {
                if(">" == substr($0, i+1, 1)) {
                    i++;
                    st = ST_Z;

                    if(attr) {
                        pattr(buffer);
                        attr = 0;
                    }

                    petag(substr(prev_tag,2));

                    buffer = "";
                } else {
                    attr = 1;
                    buffer = buffer (chr==""?"\\n":(chr=="\\"?"\\\\":chr));
                }
            } else if(">" == chr) {
                st = ST_Z;

                if(attr) {
                    pattr(buffer);
                    attr = 0;
                    buffer = "";
                } else {
                    prev_tag = buffer;
                }
            } else if(chr ~ /^[[:space:]]?$/) {
                if(attr) {
                    pattr(buffer);
                    attr = 0;
                }

                buffer = "";

                continue;
            } else if("\"" == chr) {
                st = ST_DQUOTE;
                buffer = buffer (chr==""?"\\n":(chr=="\\"?"\\\\":chr));
            } else if("'" == chr) {
                st = ST_SQUOTE;
                buffer = buffer (chr==""?"\\n":(chr=="\\"?"\\\\":chr));
            } else {
                if(buffer ~ /^</) {
                    prev_tag = buffer;
                }

                attr = 1;

                buffer = buffer (chr==""?"\\n":(chr=="\\"?"\\\\":chr));
            }
        } else if(ST_DQUOTE == st) {
            if("\"" == chr) {
                st = ST_TAG;
            }

            buffer = buffer (chr==""?"\\n":(chr=="\\"?"\\\\":chr));
        } else if(ST_SQUOTE == st) {
            if("'" == chr) {
                st = ST_TAG;
            }

            buffer = buffer (chr==""?"\\n":(chr=="\\"?"\\\\":chr));
        } else if(ST_COMMENT == st) {
            if(">" == chr && "-->" == substr($0, i-2, 3)) {
                st = ST_Z;

                pcomment(substr(buffer, 5, length(buffer)-6))

                buffer = "";
            } else {
                buffer = buffer (chr==""?"\\n":(chr=="\\"?"\\\\":chr));
            }
        } else if(ST_CDATA == st) {
            if(">" == chr && "]]>" == substr($0, i-2, 3)) {
                st = ST_Z;

                pcdata(substr(buffer, 10, length(buffer)-11));

                buffer = "";
            } else {
                buffer = buffer (chr==""?"\\n":(chr=="\\"?"\\\\":chr));
            }
        } else if(ST_PI == st) {
            # Dquote problem in case > is contained in a qstring.
            if(">" == chr && "?>" == substr($0, i-1, 2)) {
                st = ST_Z;

                ppi(buffer)

                buffer = "";
            } else {
                buffer = buffer (chr==""?"\\n":(chr=="\\"?"\\\\":chr));
            }
        }
    }
}
