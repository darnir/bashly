#!/usr/bin/awk -f

function hex(h,     ht, v) {
    ht = "0123456789abcdef";
    n = length(h);

    for(i = n; i > 0; i--) {
        v += (index(ht, substr(h, i, 1))-1) * 16 ** (n - i);
    }

    return v;
}

# I know, it's ugly, but works.
# FIXME: Use better function names, not even I remember what this means.
function xb(d,      s, n, i) {
    d = sprintf("%0"int((length(d)+1)/2)*2"d", d);

    if(d >= 128) {
        print d > "/dev/stderr"
        return "";
    }

    n = length(d);
    for(i = 1; i <= n; i += 2) {
        s = s chrtab[0+substr(d, i, 2)];
    }

    return s;
}

function entity(ent,    xb) {
    if(ent ~ /^#[[:digit:]]+$/) {
        ent = substr(ent, 2);
        return xb(ent);
    } else if(ent ~ /^#[Xx][[:xdigit:]]+$/) {
        ent = hex(tolower(substr(ent, 3)));
        return xb(ent);
    } else if(ent in entities) {
        return entities[ent];
    } else {
        print_error("x", ent);
    }
}

# Handle printing.
function px(d) {
    print d;
}

function pu(d,      s, rstart, rlength) {
    s = "";

    px(d); return;
    while(match(d, /&[^&;]+;/)) {
        rstart = RSTART;
        rlength = RLENGTH;

        s = s substr(d, 1, rstart-1);
        s = s entity(substr(d, rstart+1, rlength-2));
        d = substr(d, rstart+rlength);
    }

    print d;
}


function print_error(r, m) {
    printf "pyxawk: error: [L=%d] %s: `%s'\n", NR, r, m > "/dev/stderr";
}


function pdata(d) {
    pu("-" d);
}

function pattr(d) {
    sub(/=["']/, " ", d);
    sub(/["'][[:space:]]*$/, "", d);
    pu("A" d);
}

function pcomment(d) {
    px("#" d);
}

function pcdata(d) {
    px("$" d);
}

function petag(d) {
    px(")" d);
}

function pstag(d) {
    px("(" d);
}

function ppi(d) {
    sub(/[?][[:space:]]*$/, "", d);
    px("?" d);
}


BEGIN {
    ST_Z        = 0;
    ST_TAG      = 1;
    ST_DQUOTE   = 2;
    ST_SQUOTE   = 3;
    ST_COMMENT  = 4;
    ST_CDATA    = 5;
    ST_PI       = 6;

    entities["lt"]  = "<";
    entities["gt"]  = ">";
    entities["amp"] = "&";

    entities["nbsp"]    = " ";

    entities["aacute"]  = "á";
    entities["eacute"]  = "é";
    entities["iacute"]  = "í";
    entities["oacute"]  = "ó";
    entities["uacute"]  = "ú";
    entities["Aacute"]  = "Á";
    entities["Eacute"]  = "É";
    entities["Iacute"]  = "Í";
    entities["Oacute"]  = "Ó";
    entities["Uacute"]  = "Ú";


    # Thanks to mute for the suggestion.
    for(i = 0; i <= 6; i++) {
        chrtab[i] = sprintf("\\%o", i);
    }
    chrtab[7]   = "\\a";
    chrtab[8]   = "\\b";
    chrtab[9]   = "\\t";
    chrtab[10]  = "\\n";
    chrtab[11]  = "\\v";
    chrtab[12]  = "\\f";
    chrtab[13]  = "\\r";
    for(i = 14; i <= 31; i++) {
        chrtab[i] = sprintf("\\%03o", i);
    }
    for(i = 32; i <= 126; i++) {
        chrtab[i] = sprintf("%c", i);
    }
    for(i = 127; i <= 255; i++) {
        chrtab[i] = sprintf("\\%03o", i);
    }
}

{
    sub(/\r$/, "", $0);

    n = length;
    for(i = 1; i <= n + 1; i++) {
        chr = substr($0, i, 1);

        if(ST_Z == st) {
            if("<" == chr) {

                sstr = substr($0, i+1);
                if("!" == substr(sstr, 1, 1)) {
                    if(sstr ~ /^!--/) {
                        st = ST_COMMENT;
                    } else if(sstr ~ /^!\[CDATA\[/) {
                        st = ST_CDATA;
                    }

                    if(length(buffer)) {
                        pdata(buffer);
                    }
                    buffer = (chr==""?"\\n":(chr=="\\"?"\\\\":chr));
                } else if("?" == substr(sstr, 1, 1)) {
                    st = ST_PI;
                } else if(match(substr($0, i), /^<\/[^<&>/[:space:]]+/)) {
                    rstart = RSTART;
                    rlength = RLENGTH;
                    st = ST_Z;

                    if(attr) {
                        pattr(buffer);
                        attr = 0;
                        buffer = "";
                    }

                    if(length(buffer)) {
                        pdata(buffer);
                        buffer = "";
                    }

                    petag(substr($0, i+rstart+1, rlength-2));

                    i += rlength;

                    if(">" != substr($0, i, 1)) {

                        if("" != substr($0, i, 1)) {
                            print_error("expecting space", substr($0, i));
                        }

                        break_flag = 1;
                        while(break_flag) {
                            if(0 > getline) {
                                print_error("expecting >", "<EOF>");
                            }

                            n = length;
                            for(i = 1; i <= n; i++) {
                                chr = substr($0, i, 1);

                                if(chr ~ /^[[:space:]]?$/) {
                                    continue;
                                } else if(">" != chr) {
                                    print_error("expecting >", substr($0, i));
                                }

                                break_flag = 0;
                                break;
                            }

                        }
                    }
                } else {
                    st = ST_TAG;

                    if(length(buffer)) {
                        pdata(buffer);
                        buffer = "";
                    }

                    # I know, NameChar, but, it's easier this way...
                    if(match(substr($0, i), /^<[^<&>/[:space:]]+/)) {
                        rstart = RSTART;
                        rlength = RLENGTH;

                        prev_tag = substr($0, i+rstart-1, rlength)

                        pstag(substr($0, i+rstart, rlength-1));

                        i += rlength - 1;
                    } else {
                        st = ST_Z;

                        print_error("unexpected <", substr($0, i));
                    }
                }
            } else {
                buffer = buffer (chr==""?"\\n":(chr=="\\"?"\\\\":chr));
            }
        } else if(ST_TAG == st) {
            if("<" == chr) {
                s = ST_Z;

                print_error("unexpected <", substr($0, i));
            } else if("/" == chr) {
                if(">" == substr($0, i+1, 1)) {
                    i++;
                    st = ST_Z;

                    if(attr) {
                        pattr(buffer);
                        attr = 0;
                    }

                    petag(substr(prev_tag,2));

                    buffer = "";
                } else {
                    attr = 1;
                    buffer = buffer (chr==""?"\\n":(chr=="\\"?"\\\\":chr));
                }
            } else if(">" == chr) {
                st = ST_Z;

                if(attr) {
                    pattr(buffer);
                    attr = 0;
                    buffer = "";
                } else {
                    prev_tag = buffer;
                }
            } else if(chr ~ /^[[:space:]]?$/) {
                if(attr) {
                    pattr(buffer);
                    attr = 0;
                }

                buffer = "";

                continue;
            } else if("\"" == chr) {
                st = ST_DQUOTE;
                buffer = buffer (chr==""?"\\n":(chr=="\\"?"\\\\":chr));
            } else if("'" == chr) {
                st = ST_SQUOTE;
                buffer = buffer (chr==""?"\\n":(chr=="\\"?"\\\\":chr));
            } else {
                if(buffer ~ /^</) {
                    prev_tag = buffer;
                }

                attr = 1;

                buffer = buffer (chr==""?"\\n":(chr=="\\"?"\\\\":chr));
            }
        } else if(ST_DQUOTE == st) {
            if("\"" == chr) {
                st = ST_TAG;
            }

            buffer = buffer (chr==""?"\\n":(chr=="\\"?"\\\\":chr));
        } else if(ST_SQUOTE == st) {
            if("'" == chr) {
                st = ST_TAG;
            }

            buffer = buffer (chr==""?"\\n":(chr=="\\"?"\\\\":chr));
        } else if(ST_COMMENT == st) {
            if(">" == chr && "-->" == substr($0, i-2, 3)) {
                st = ST_Z;

                pcomment(substr(buffer, 5, length(buffer)-6))

                buffer = "";
            } else {
                buffer = buffer (chr==""?"\\n":(chr=="\\"?"\\\\":chr));
            }
        } else if(ST_CDATA == st) {
            if(">" == chr && "]]>" == substr($0, i-2, 3)) {
                st = ST_Z;

                pcdata(substr(buffer, 10, length(buffer)-11));

                buffer = "";
            } else {
                buffer = buffer (chr==""?"\\n":(chr=="\\"?"\\\\":chr));
            }
        } else if(ST_PI == st) {
            # Dquote problem in case > is contained in a qstring.
            if(">" == chr && "?>" == substr($0, i-1, 2)) {
                st = ST_Z;

                ppi(buffer)

                buffer = "";
            } else {
                buffer = buffer (chr==""?"\\n":(chr=="\\"?"\\\\":chr));
            }
        }
    }
}
