#!/usr/bin/awk -f

# pyxawk by dualbus

###############################################################################
# Bitwise math by Scott S. McCoy
###############################################################################
# A small collection of bitwise operations.
# -----------------------------------------------------------------------------
# "THE BEER-WARE LICENSE" (Revision 43) borrowed from FreeBSD's jail.c:
# <tag@cpan.org> wrote this file.  As long as you retain this notice you
# can do whatever you want with this stuff. If we meet some day, and you think
# this stuff is worth it, you can buy me a beer in return.   Scott S. McCoy
# -----------------------------------------------------------------------------
function bit_right  (value, distance) { return value / (2 ^ distance); }
function bit_left   (value, distance) { return value * (2 ^ distance); }

function bit_and (a, b, r, i, c, ia, ib) {
    r = 0

    for (i = 0; i < 32; i++) {
        c = 2 ^ i

        ia = int(a / c) % 2
        ib = int(b / c) % 2

        r += (ia && ib) * c
    }

    return r
}

function bit_or (a, b, r, i, ia, ib) {
    r = 0

    for (i = 0; i < 32; i++) {
        c = 2 ^ i

        ia = int(a / c) % 2
        ib = int(b / c) % 2

        r += (ia || ib) * c
    }

    return r
}
###############################################################################


function hex(hex_string,     hextab, n, i, value) {
    hextab = "0123456789abcdef";
    n = length(hex_string);

    value = 0;
    for(i = n; i > 0; i--) {
        value += (index(hextab, substr(hex_string, i, 1))-1) * 16 ^ (n - i);
    }

    return value;
}

function char_utf8(codepoint,     s) {
    codepoint = codepoint+0;

            if(0            <= codepoint && codepoint <= 127        ) {
        return chartab[bytes[1]];
    } else  if(127          <  codepoint && codepoint <= 2047       ) {
        s = "";
        s = s chartab[bit_or(192, bit_and(31,   bit_right(codepoint, 6)))];
        s = s chartab[bit_or(128, bit_and(63,   codepoint))];
        return s;
    } else  if(2047         <  codepoint && codepoint <= 65535      ) {
        s = "";
        s = s chartab[bit_or(224, bit_and(15,   bit_right(codepoint, 12)))];
        s = s chartab[bit_or(128, bit_and(63,   bit_right(codepoint, 6)))];
        s = s chartab[bit_or(128, bit_and(63,   codepoint))];
        return s;
    } else  if(65535        <  codepoint && codepoint <= 2097151    ) {
        s = "";
        s = s chartab[bit_or(240, bit_and(7,    bit_right(codepoint, 18)))];
        s = s chartab[bit_or(128, bit_and(63,   bit_right(codepoint, 12)))];
        s = s chartab[bit_or(128, bit_and(63,   bit_right(codepoint, 6)))];
        s = s chartab[bit_or(128, bit_and(63,   codepoint))];
        return s;
    } else  if(2097151      <  codepoint && codepoint <= 67108863   ) {
        s = "";
        s = s chartab[bit_or(248, bit_and(3,    bit_right(codepoint, 24)))];
        s = s chartab[bit_or(128, bit_and(63,   bit_right(codepoint, 18)))];
        s = s chartab[bit_or(128, bit_and(63,   bit_right(codepoint, 12)))];
        s = s chartab[bit_or(128, bit_and(63,   bit_right(codepoint, 6)))];
        s = s chartab[bit_or(128, bit_and(63,   codepoint))];
        return s;
    } else  if(67108863     <  codepoint && codepoint <= 2147483647 )
    {
        s = "";
        s = s chartab[bit_or(252, bit_and(1,    bit_right(codepoint, 30)))];
        s = s chartab[bit_or(128, bit_and(63,   bit_right(codepoint, 24)))];
        s = s chartab[bit_or(128, bit_and(63,   bit_right(codepoint, 18)))];
        s = s chartab[bit_or(128, bit_and(63,   bit_right(codepoint, 12)))];
        s = s chartab[bit_or(128, bit_and(63,   bit_right(codepoint, 6)))];
        s = s chartab[bit_or(128, bit_and(63,   codepoint))];
        return s;
    }
}

function decode_entity(entity_) {
    entity_name = substr(entity_, 2, length(entity_) - 2)

    if(entity_name ~ /^#[[:digit:]]+$/) {
        entity_name = substr(entity_name, 2);

        return char_utf8(entity_name);

    } else if(entity_name ~ /^#[Xx][[:xdigit:]]+$/) {
        entity_name = hex(tolower(substr(entity_name, 3)));

        return char_utf8(entity_name);

    } else if(entity_name in entities) {
        return entities[entity_name];

    } else {
        print_error("unknown entity", entity_name);
    }
}


#-------------------------------------------------------------------------------
# Printing functions.
#-------------------------------------------------------------------------------
function print_error(reason, message,      error_fmt) {
    gsub(/`/, "\\`", message);
    gsub(/'/, "\\'", message);

    error_fmt = "pyxawk: error: [R=%d,C=%d] %s: `%s'%s";
    printf error_fmt, NR, X_C, reason, message, ORS > "/dev/stderr";
}

function print_starttag(data) {
    print("(" data);
}

function print_endtag(data) {
    print(")" data);
}

function print_chardata(data) {
    print("-" data);
}

function print_cdata(data) {
    print("[" data);
}

function print_entity(entity) {
    print_chardata(decode_entity(entity));
}

function print_attribute(name, value) {
    print("A" name " " value);
}

function print_comment(data) {
    print("C" data);
}

function print_doctype(data) {
    print("D" data);
}

function print_pi(data) {
    print("?" data);
}
#-------------------------------------------------------------------------------


#-------------------------------------------------------------------------------
function get_line(i,      result) {
        result = getline;
        if(result == 0) {
            print_error("unexpected end of file", substr($0, i));
        } else if(result == -1) {
            print_error("error reading file", substr($0, i));
        }
}

function consume_name(i,        substr_, re_name, rlength) {
    re_name = "^[[:alpha:]:_][[:alpha:]:_[:digit:]-]*";
    X_RNAME = "";

    match(substr($0, i), re_name);
    rlength = RLENGTH;

    X_RNAME = substr($0, i, rlength);

    return i+rlength; 
}

function consume_entity(i,      re_entity, rlength) {
    re_entity = "^&[^&;]+;";
    X_RENTITY = "";

    match(substr($0, i), re_entity);
    rlength = RLENGTH;

    X_RENTITY = substr($0, i, rlength);

    return i+rlength+1; 
}

function consume_qstring(qchar, i,      j, k, r) {
    X_RVALUE = "";

    if(substr($0, i, 1) != qchar) {
        print_error("expecting <" qchar ">", substr($0, i));
        return i;
    }

    i++;
    while(1) {
        do {
            j = index(substr($0, i), qchar);
            k = index(substr($0, i), "&");

            if(j > 0 && (j < k || k <= 0)) {
                X_RVALUE = X_RVALUE substr($0, i, j-1);
                i += j;
                return i;
            } else if(k > 0) {
                X_RVALUE = X_RVALUE substr($0, i, k-1)
                i = consume_entity(i+k-1);
                X_RVALUE = X_RVALUE decode_entity(X_RENTITY);
                i++;
            }
        } while(j > 0 && k > 0);

        X_RVALUE = X_RVALUE substr($0, i) "\\n";
        get_line(i);
        i = 1;
    }

    return i;
}

function consume_whitespace(i,      result) {
    while(1) {
        for(; i <= length; i++) {
            if(substr($0, i, 1) !~ /[[:space:]]/) {
                return i;
            }
        }

        get_line(i);
        i = 1;
    }
}

function consume_comment(i,      buffer, j, result) {
    if(substr($0, i) !~ /^<!--/) {
        print_error("expecting `<!--'", substr($0, i));
        return i;
    }

    i += 4;
    buffer = "";
    while(1) {
        if(0 < (j=index(substr($0, i), "-->"))) {
            print_comment(buffer substr($0, i, j-1));
            return i+j+1;
        }
        buffer = buffer substr($0, i) "\\n";
        get_line(i);
        i = 1;
    }

    return i;
}

function consume_cdata(i,      buffer, j, result) {
    if(substr($0, i) !~ /^<!\[CDATA\[/) {
        print_error("expecting `<![CDATA['", substr($0, i));
        return i;
    }

    i += 9;
    buffer = "";
    while(1) {
        if(0 < (j=index(substr($0, i), "]]>"))) {
            print_cdata(buffer substr($0, i, j-1));
            return i+j+1;
        }
        buffer = buffer substr($0, i) "\\n";
        get_line(i);
        i = 1;
    }

    return i;
}

function consume_doctype(i) {
    if(substr($0, i) !~ /^<!DOCTYPE/) {
        print_error("expecting `<!DOCTYPE'", substr($0, i));
        return i;
    }

    i += 9;
    buffer = "";
    while(1) {
        if(0 < (j=index(substr($0, i), ">"))) {
            print_doctype(buffer substr($0, i, j-1));
            return i+j+1;
        }
        buffer = buffer substr($0, i) "\\n";
        get_line(i);
        i = 1;
    }

    return i;
}

function consume_pi(i) {
    if(substr($0, i) !~ /^<?/) {
        print_error("expecting `<?'", substr($0, i));
        return i;
    }

    i += 2;
    buffer = "";
    while(1) {
        if(0 < (j=index(substr($0, i), "?>"))) {
            print_pi(buffer substr($0, i, j-1));
            return i+j+1;
        }
        buffer = buffer substr($0, i) "\\n";
        get_line(i);
        i = 1;
    }

    return i;
}

function consume_chardata(i,      chardata, n, r) {
    chardata = "";

    while(1) {
        n = length;
        for(; i <= n; i++) {
            if(substr($0, i, 1) ~ /^[<&]/) {
                if(0 < length(chardata)) {
                    print_chardata(chardata);
                }

                return i;
            }
            chardata = chardata substr($0, i, 1);
        }

        chardata = chardata "\\n";
        get_line(i);
        i = 1;
    }
}

function consume_starttag(i,        save_i, save_rname, j) {
    if(substr($0, i, 1) != "<") {
        print_error("expecting `<'", substr($0, i));
        return i;
    }

    save_i = i

    i++;
    i = consume_whitespace(i);
    i = consume_name(i);
    save_rname = X_RNAME;
    print_starttag(save_rname);
    j = i;
    do {
        i = j;
        i = consume_whitespace(i);
        j = consume_attribute(i);
    } while(j>i);
    i = consume_whitespace(i);

    if(substr($0, i, 1) == "/") {
        i++;
        print_endtag(save_rname);
    }

    i = consume_whitespace(i);

    if(substr($0, i, 1) != ">") {
        print_error("Missing closing `>'", substr($0, save_i));
    }

    return i;
}

function consume_attribute(i,       name, value) {
    value = "";

    i = consume_whitespace(i);
    i = consume_name(i);
    name = X_RNAME;
    if(0 >= length(name)) {
        return i;
    }

    if(substr($0, i, 1) == "=") {
        i++;
        if(substr($0, i, 1) ~ /['"]/) {
            i = consume_qstring(substr($0, i, 1), i);
            value = X_RVALUE;
        } else {
            i = consume_name(i);
            value = X_RNAME;
        }
    }

    print_attribute(name, value);

    return i;
}

function consume_endtag(i) {
    if(substr($0, i, 2) != "</") {
        print_error("expecting `</'", substr($0, i));
        return i;
    }

    i += 2;
    i = consume_whitespace(i);
    i = consume_name(i);
    print_endtag(X_RNAME);

    if(substr($0, i, 1) != ">") {
        print_error("missing closing `>'", substr($0, i));
    }

    return i;
}
#-------------------------------------------------------------------------------



#===============================================================================
BEGIN {
#-------------------------------------------------------------------------------
# XML entities.
#-------------------------------------------------------------------------------
entities["lt"]      = "<";
entities["gt"]      = ">";
entities["amp"]     = "&";
#-------------------------------------------------------------------------------

#-------------------------------------------------------------------------------
# Misc. entities.
#-------------------------------------------------------------------------------
entities["quot"]    = "\"";
entities["nbsp"]    = " ";
entities["raquo"]   = "»";
entities["laquo"]   = "«";
entities["rsaquo"]  = "›";
entities["lsaquo"]  = "‹";
entities["rdquo"]   = "”";
entities["ldquo"]   = "“";
entities["aacute"]  = "á";
entities["eacute"]  = "é";
entities["iacute"]  = "í";
entities["oacute"]  = "ó";
entities["uacute"]  = "ú";
entities["Aacute"]  = "Á";
entities["Eacute"]  = "É";
entities["Iacute"]  = "Í";
entities["Oacute"]  = "Ó";
entities["Uacute"]  = "Ú";
#-------------------------------------------------------------------------------


#-------------------------------------------------------------------------------
# chartab. Handle c-style escaping.
#-------------------------------------------------------------------------------
octal_fmt = "\\%03o";
for(i =   0;  i <=   6; i++) { chartab[i] = sprintf(octal_fmt,   i); }
chartab[7]   = "\\a";
chartab[8]   = "\\b";
chartab[9]   = "\\t";
chartab[10]  = "\\n";
chartab[11]  = "\\v";
chartab[12]  = "\\f";
chartab[13]  = "\\r";
for(i =  14;  i <=  31; i++) { chartab[i] = sprintf(octal_fmt,  i); }
for(i =  32;  i <= 126; i++) { chartab[i] = sprintf("%c",       i); }
# You have to set LC_ALL=c
for(i = 127;  i <= 255; i++) { chartab[i] = sprintf("%c",       i); }
#-------------------------------------------------------------------------------
} # BEGIN
#===============================================================================



#-------------------------------------------------------------------------------
# Main program.
#-------------------------------------------------------------------------------
{
    # Remove CRs.
    gsub(/\r*/, "");

    for(X_C = 1; X_C <= length; X_C++) {
        if(substr($0, X_C, 1) != "<") {
            X_C = consume_whitespace(X_C);
            X_C = consume_chardata(X_C);
            X_C = consume_whitespace(X_C);
        }

        if(substr($0, X_C) ~ /^<\//) {
            X_C = consume_endtag(X_C);
        } else if(substr($0, X_C) ~ /^<\?/) {
            X_C = consume_pi(X_C);
        } else if(substr($0, X_C) ~ /^<!/) {
            if(substr($0, X_C) ~ /^<!--/) {
                X_C = consume_comment(X_C);
            } else if(substr($0, X_C) ~ /^<!\[CDATA\[/) {
                X_C = consume_cdata(X_C);
            } else if(substr($0, X_C) ~ /^<!/) {
                X_C = consume_doctype(X_C);
            }
        } else if(substr($0, X_C) ~ /^&/) {
            X_C = consume_entity(X_C);
            print_entity(X_RENTITY);
        } else {
            X_C = consume_starttag(X_C);
        }
    }

    print_chardata("\\n");
}
