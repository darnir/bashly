#! /usr/bin/env bash

die() {
    for arg; do
        printf '%s: %s\n' "$BASH_SOURCE" "$arg" >&2
    done
    exit 1
}

chr() {
    printf \\$(($1/64*100+$1%64/8*10+$1%8))
} 

# Translates a character to its decimal ASCII value.
declare -A _ord=()
for ((i=1; i<256; i++)); do
    c=$(chr $i)
    _ord["${c:-$'\n'}"]=$i
done
ord() {
    if ((1 == $#)); then
        c=${1:0:1}
        if [[ $c ]]; then
            printf %d "${_ord[$c]}"
        else
            printf 0
        fi
    fi
}

# Percent-encode's a stream of characters.
penc() {
    # RFC3986
    declare c i block
    while IFS= read -r block; do
        for ((i=0; i<${#block}; i++)); do
            c=${block:i:1}
            if [[ $c = [[:alpha:].~-] ]]; then
                printf %s "$c"
            else
                printf %%%02X "$(ord "$c")"
            fi
        done
        printf %%0a
    done
    for ((i=0; i<${#block}; i++)); do
        c=${block:i:1}
        if [[ $c = [[:alpha:].~-] ]]; then
            printf %s "$c"
        else
            printf %%%02X "$(ord "$c")"
        fi
    done
}

# Percent-encode's a stream of character, but instead of representing spaces as
# '%20' it represents them as '+'.
fuenc() {
    # application/x-www-form-urlencoded
    declare c i block
    while IFS= read -r block; do
        for ((i=0; i<${#block}; i++)); do
            c=${block:i:1}
            if [[ $c = [[:alpha:].~-] ]]; then
                printf %s "$c"
            elif [[ $c = ' ' ]]; then
                printf +
            else
                printf %%%02X "$(ord "$c")"
            fi
        done
        printf %%0a
    done
    for ((i=0; i<${#block}; i++)); do
        c=${block:i:1}
        if [[ $c = [[:alpha:].~-] ]]; then
            printf %s "$c"
        elif [[ $c = ' ' ]]; then
            printf +
        else
            printf %%%02X "$(ord "$c")"
        fi
    done
}

pdec() {
    declare data=${1//\\/\\\\}
    printf "${data//\%/\\x}"
}

fudec() {
    declare data=${1//'+'/'%20'}
    pdec "$data"
}

# Convert to a QS an associative array of arguments previously percent-encoded.
# The arguments are expected to be in this order:
#   k0 k1 k2 ... kn v0 v1 v2 ... vn
# where 'ki' is the key corresponding to the 'vi' value.
url_encode() {
    declare offset=$(($#/2))
    declare i key value sep
    sep=
    for ((i=1;i<=offset;i++)); do
        printf %s%s=%s "$sep" "${@:i:1}" "${@:i+offset:1}"
        sep='&'
    done
}

# Parses a simple URL into its components.
# It returns a space separated list of the retrieved elements; in case an
# element is missing, a '?' will be used as a place-holder.
url_parse() {
    local url=$1 x y
    local scheme userpwd username password
    local netloc fqdn port path qs frag
    local -a parts
    IFS=':' read -r scheme x <<< "$url"
    if [[ $x != '//'* ]]; then
        scheme=
        x=//$url
    fi
    x=${x#//}
    IFS=@ read -r userpwd x <<< "$x"
    if [[ ! $x ]]; then
        x=$userpwd userpwd=
    fi
    IFS=':' read -r username password <<< "$userpwd"
    IFS='/' read -r netloc x <<< "$x"
    IFS=':?' read -r fqdn port y <<< "$netloc"
    if [[ $y ]]; then
        x=?$y
    fi
    port=${port:-80}
    IFS='?' read -r path x <<< "$x"
    path=/$path
    IFS='#' read -r qs frag <<< "$x"
    parts=( "$scheme" "$username" "$password"
            "$fqdn" "$port" "$path" "$qs" "$frag")
    (IFS=':'; printf '%s\n' "${parts[*]}")
}

http_get() {
    declare url=$1 fqdn port path qs frag res
    declare -a req=()
    IFS=: read -r _ _ _ fqdn port path qs frag < <(url_parse "$url")
    res=$path
    [[ $qs ]] && res+=?$qs
    [[ $frag ]] && res+=#$frag
    req+=("GET $res HTTP/1.0")
    req+=("Host: $fqdn")
    req+=('')
    { exec 3<>"/dev/tcp/$fqdn/$port"; } 2>/dev/null || die 'Connection refused'
    printf '%s\r\n' "${req[@]}" >&3
    while IFS= read -r line; do printf '%s\n' "$line"; done <&3
    exec 3>&-
}

http_post() {
    declare url=$1 form=$2 fqdn port path qs frag res
    declare -a req=()
    IFS=: read -r _ _ _ fqdn port path qs frag < <(url_parse "$url")
    res=$path
    [[ $qs ]] && res+=?$qs
    [[ $frag ]] && res+=#$frag
    req+=("POST $res HTTP/1.0")
    req+=("Host: $fqdn")
    req+=("Content-Type: application/x-www-form-urlencoded")
    req+=("Content-Length: $((${#form}+2))") # form + \r\n
    req+=('')
    req+=("$form")
    { exec 3<>"/dev/tcp/$fqdn/$port"; } 2>/dev/null || die 'Connection refused'
    printf '%s\r\n' "${req[@]}" >&3
    while IFS= read -r line; do printf '%s\n' "$line"; done <&3
    exec 3>&-
}

# The real deal.
if ((0 < $#)); then
    file=$1
else
    file=/dev/stdin
fi
content=$(fuenc < "$file")
qs=$(url_encode content "$content")
{
    read
    while read -r line; do
        line=${line%$'\r'}
        if [[ $line = *:* ]]; then
            IFS=: read -r key value <<< "$line"
            value=${value#[[:space:]]}
            if [[ $key = Location ]]; then
                printf '%s\n' "$value"
            fi
        else
            exit 1
        fi
    done
} < <(http_post 'http://dpaste.com/api/v1/' "$qs")
