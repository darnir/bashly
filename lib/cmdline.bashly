#!/bin/bash

: load object


function cmdline__p__arguments__short {
  typeset short
  typeset name
  typeset arguments
  typeset i
  typeset -a options
  typeset -A arguments_table
  typeset -A name_table

  IFS=';' read -ra options <<< "$1"; shift

  for option in "${options[@]}"; do
    IFS=':' read -r name short _ arguments <<< "$option"
    arguments_table["$short"]=$arguments
    name_table["$short"]=$name
  done

  [[ $1 = -[!-] ]] || return 1

  [[ ${arguments_table["${1#-}"]+set} ]] || return 1
  [[ ${name_table["${1#-}"]+set} ]] || return 1

  arguments=${arguments_table["${1#-}"]}
  name=${name_table["${1#-}"]}

  shift

  ((arguments <= $#)) || return 1

  printf %s "$((arguments + 1))"

  if ((arguments > 0)); then
    for ((i = 1; i <= arguments; i++)); do
      printf '%s:%s\0' "$name" "${!i}"
    done
  else
    printf '%s\0' "$name"
  fi >&3
}


function cmdline__p__arguments__short_composed {
  typeset options_description=$1
  typeset short
  typeset rest
  typeset arguments
  typeset shift
  typeset flag
  typeset i
  typeset -a options
  typeset -a flags
  typeset -a last_option
  typeset -A arguments_table

  IFS=';' read -ra options <<< "$options_description"; shift

  for option in "${options[@]}"; do
    IFS=':' read -r name short _ arguments <<< "$option"
    arguments_table["$short"]=$arguments
  done

  rest=$1; shift

  while [[ $rest ]]; do
    short=${rest#-} rest=${short#?} short=${short%"$rest"}

    [[ ${arguments_table["$short"]+set} ]] || return 1

    arguments=${arguments_table["$short"]}

    if ((arguments == 0)); then
      flags+=("-$short")
    elif ((arguments > 0)) && [[ $rest ]]; then
      last_option=("-$short" "$rest" "$@") shift=$arguments
      break
    elif ((arguments > 0)); then
      last_option=("-$short" "$@") shift=$((arguments + 1))
      break
    else
      return 1
    fi
  done

  if [[ $last_option ]]; then
    printf %s $shift
  else
    printf %s 1
  fi

  for flag in "${flags[@]}"; do
    cmdline__p__arguments__short "$options_description" "$flag" \
      >/dev/null
  done

  cmdline__p__arguments__short "$options_description" \
    "${last_option[@]}" >/dev/null
}


function cmdline__p__arguments__long {
  typeset long
  typeset name
  typeset arguments
  typeset i
  typeset -a options
  typeset -A arguments_table
  typeset -A name_table

  IFS=';' read -ra options <<< "$1"; shift

  for option in "${options[@]}"; do
    IFS=':' read -r name _ long arguments <<< "$option"
    arguments_table["$long"]=$arguments
    name_table["$long"]=$name
  done

  [[ $1 = --[!-]* ]] || return 1

  [[ ${arguments_table["${1#--}"]+set} ]] || return 1
  [[ ${name_table["${1#--}"]+set} ]] || return 1

  arguments=${arguments_table["${1#--}"]}
  name=${name_table["${1#--}"]}

  shift

  ((arguments <= $#)) || return 1

  printf %s "$((arguments + 1))"

  if ((arguments > 0)); then
    for ((i = 1; i <= arguments; i++)); do
      printf '%s:%s\0' "$name" "${!i}"
    done
  else
    printf '%s\0' "$name"
  fi >&3
}


function cmdline__p__parse_descriptions {
  typeset option_description
  typeset option_object
  typeset key
  typeset value
  typeset shift
  typeset argument
  typeset name
  typeset short
  typeset long
  typeset -a option_descriptions

  option_object='name;short;long;arguments;help'

  shift=0

  for option_description do
    [[ $option_description = '--' ]] && break

    ((shift++))

    name= short= long= arguments=0
    while IFS=: read -rd '' key value; do
      case $key in
        -*)
          return 1
          ;;

        name|short|long|arguments)
          typeset "$key=$value"
          ;;
      esac
    done < <(object__new "$option_object" "$option_description")

    option_descriptions+=("$name:$short:$long:$arguments")
  done

  (IFS=';'; printf %s:%s "$shift" "${option_descriptions[*]}")
}


function cmdline__p__consume_arguments {
  typeset options=$1; shift
  typeset argument
  typeset stop_parsing
  typeset helper


  while (($# > 0)); do
    if [[ $stop_parsing ]]; then
        printf '@:%s\0' "$1"; shift; continue;
    fi

    helper=
    case $1 in
      -[!-])
        helper=cmdline__p__arguments__short
        ;;

      -[!-]*)
        helper=cmdline__p__arguments__short_composed
        ;;

      --[!-]*)
        if [[ $1 = --+([!=-])=* ]]; then
          IFS='=' read -rd '' key value <<< "$1";
          value=${value%$'\n'}
          shift 1
          set -- "$key" "$value" "$@"
        fi

        helper=cmdline__p__arguments__long
        ;;

      --)
        stop_parsing=y
        ;;

      *)
        printf '@:%s\0' "$1"
        ;;
    esac

    if [[ $helper ]]; then
      { shift=$("$helper" "$options" "$@") || return 1; } 3>&1

      shift "$((shift))"
    else
      shift
    fi
  done
}


function cmdline__arguments {
  : <<EOD
  cmdline__arguments 

  env vars:

  - errors_not_fatal
  - dashdash_not_special
EOD

  typeset key
  typeset value
  typeset shift
  typeset argument
  typeset options
  typeset stop_parsing
  typeset return_code

  IFS=: read -rd '' shift options < \
    <(cmdline__p__parse_descriptions "$@") || return

  shift "${shift:-0}"

  if [[ $1 = '--' ]]; then
    shift
  else
    return 2
  fi

  cmdline__p__consume_arguments "$@"
}


function cmdline__help {
  :
}
